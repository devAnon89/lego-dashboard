<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üß± LEGO Investment Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    body { font-family: 'Inter', sans-serif; background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 100%); }
    .card { background: rgba(255,255,255,0.05); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
    .glow-green { box-shadow: 0 0 20px rgba(34, 197, 94, 0.3); }
    .glow-red { box-shadow: 0 0 20px rgba(239, 68, 68, 0.3); }
    .glow-yellow { box-shadow: 0 0 20px rgba(234, 179, 8, 0.3); }
    .glow-purple { box-shadow: 0 0 20px rgba(168, 85, 247, 0.3); }
    .score-bar { background: linear-gradient(90deg, #ef4444 0%, #eab308 50%, #22c55e 100%); }
    .tab-active { border-bottom: 2px solid #3b82f6; color: #3b82f6; }
    .prediction-badge { background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%); }
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 4px; }
  </style>
</head>
<body class="min-h-screen text-white p-4 md:p-8">
  <!-- Header -->
  <header class="mb-8">
    <div class="flex items-center justify-between flex-wrap gap-4">
      <div>
        <h1 class="text-3xl md:text-4xl font-bold">üß± LEGO Investment Dashboard</h1>
        <p class="text-gray-400 mt-1">AI-Powered Portfolio Analysis with BrickEconomy ML Predictions</p>
      </div>
      <div class="flex items-center gap-4">
        <span class="text-sm text-gray-400" id="lastUpdated"></span>
        <button onclick="refreshData()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium transition">üîÑ Refresh</button>
      </div>
    </div>
  </header>

  <!-- Summary Cards -->
  <div class="grid grid-cols-2 md:grid-cols-5 gap-4 mb-8" id="summaryCards">
    <div class="card rounded-xl p-4">
      <div class="text-gray-400 text-sm">Total Value</div>
      <div class="text-2xl font-bold text-white" id="totalValue">-</div>
      <div class="text-sm text-gray-500" id="totalPaid"></div>
    </div>
    <div class="card rounded-xl p-4">
      <div class="text-gray-400 text-sm">Total Gain/Loss</div>
      <div class="text-2xl font-bold" id="totalGain">-</div>
      <div class="text-sm" id="totalGainPct"></div>
    </div>
    <div class="card rounded-xl p-4">
      <div class="text-gray-400 text-sm">Total Sets</div>
      <div class="text-2xl font-bold text-white" id="totalSets">-</div>
      <div class="text-sm text-gray-500" id="totalUnits"></div>
    </div>
    <div class="card rounded-xl p-4">
      <div class="text-gray-400 text-sm">Avg Score</div>
      <div class="text-2xl font-bold text-blue-400" id="avgScore">-</div>
      <div class="text-sm text-gray-500">out of 10</div>
    </div>
    <div class="card rounded-xl p-4 glow-purple">
      <div class="text-gray-400 text-sm flex items-center gap-1">
        üîÆ 1yr Forecast
        <span class="text-xs text-purple-400">(ML)</span>
      </div>
      <div class="text-2xl font-bold text-purple-400" id="forecast1yr">-</div>
      <div class="text-sm text-purple-300" id="forecast1yrGrowth"></div>
    </div>
  </div>

  <!-- Portfolio History Chart -->
  <div class="card rounded-xl p-4 mb-8">
    <div class="flex items-center justify-between mb-4">
      <h3 class="text-lg font-semibold flex items-center gap-2">üìà Portfolio Value History</h3>
      <div class="flex items-center gap-2">
        <span class="text-xs text-gray-400">Based on price history from BrickEconomy</span>
        <select id="historyRange" class="bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" onchange="updateHistoryChart()">
          <option value="6">6 Months</option>
          <option value="12" selected>1 Year</option>
          <option value="24">2 Years</option>
          <option value="all">All Time</option>
        </select>
      </div>
    </div>
    <div class="h-64">
      <canvas id="historyChart"></canvas>
    </div>
  </div>

  <!-- Future Projections Section -->
  <div class="card rounded-xl p-4 mb-8">
    <div class="flex items-center justify-between mb-4">
      <h3 class="text-lg font-semibold flex items-center gap-2">üîÆ Future Projections</h3>
      <span class="prediction-badge px-3 py-1 rounded-full text-xs font-medium">Powered by BrickEconomy ML</span>
    </div>
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
      <div class="bg-gradient-to-br from-purple-900/30 to-indigo-900/30 rounded-xl p-4 border border-purple-500/20">
        <div class="flex items-center gap-2 mb-3">
          <span class="text-purple-400">üìÖ</span>
          <span class="text-sm font-medium text-purple-300">1-Year Projection (Jan 2026)</span>
        </div>
        <div class="text-3xl font-bold text-white mb-2" id="projection1yr">-</div>
        <div class="text-sm" id="projection1yrChange">-</div>
        <div class="mt-3 text-xs text-gray-400">
          Based on BrickEconomy's machine learning model trained on historical LEGO market data
        </div>
      </div>
      <div class="bg-gradient-to-br from-indigo-900/30 to-blue-900/30 rounded-xl p-4 border border-indigo-500/20">
        <div class="flex items-center gap-2 mb-3">
          <span class="text-indigo-400">üìÖ</span>
          <span class="text-sm font-medium text-indigo-300">5-Year Projection (Jan 2030)</span>
        </div>
        <div class="text-3xl font-bold text-white mb-2" id="projection5yr">-</div>
        <div class="text-sm" id="projection5yrChange">-</div>
        <div class="mt-3 text-xs text-gray-400">
          Long-term estimate based on historical appreciation patterns for retired sets
        </div>
      </div>
    </div>
    <div class="mt-4 p-3 bg-yellow-500/10 border border-yellow-500/20 rounded-lg">
      <p class="text-xs text-yellow-300">
        ‚ö†Ô∏è <strong>Disclaimer:</strong> Predictions are generated by BrickEconomy's ML model and are estimates only. 
        Actual future values may vary significantly based on market conditions, rarity, and collector demand.
      </p>
    </div>
  </div>

  <!-- Theme Allocation Chart -->
  <div class="card rounded-xl p-4 mb-8">
    <div class="flex items-center justify-between mb-4">
      <h3 class="text-lg font-semibold flex items-center gap-2">üé® Portfolio by Theme</h3>
      <span class="text-xs text-gray-400">Value allocation across LEGO themes</span>
    </div>
    <div class="h-80">
      <canvas id="themeChart"></canvas>
    </div>
  </div>

  <!-- Theme Performance History Chart -->
  <div class="card rounded-xl p-4 mb-8">
    <div class="flex items-center justify-between mb-4">
      <h3 class="text-lg font-semibold flex items-center gap-2">üìä Theme Performance History</h3>
      <div class="flex items-center gap-2">
        <span class="text-xs text-gray-400">Top 5 themes by value over time</span>
        <select id="themeHistoryRange" class="bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" onchange="updateThemeHistoryChart()">
          <option value="6">6 Months</option>
          <option value="12" selected>1 Year</option>
          <option value="24">2 Years</option>
          <option value="all">All Time</option>
        </select>
      </div>
    </div>
    <div class="h-64">
      <canvas id="themeHistoryChart"></canvas>
    </div>
  </div>

  <!-- Theme ROI Comparison Table -->
  <div class="card rounded-xl p-4 mb-8">
    <div class="flex items-center justify-between mb-4">
      <h3 class="text-lg font-semibold flex items-center gap-2">üí∞ Theme ROI Comparison</h3>
      <div class="flex items-center gap-2">
        <span class="text-xs text-gray-400">Click headers to sort</span>
        <select id="themeROISort" class="bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" onchange="renderThemeROITable()">
          <option value="roi">Sort by ROI</option>
          <option value="value">Sort by Value</option>
          <option value="gain">Sort by Gain</option>
          <option value="theme">Sort by Theme</option>
        </select>
      </div>
    </div>
    <div class="overflow-x-auto">
      <table class="w-full text-sm">
        <thead>
          <tr class="border-b border-gray-700">
            <th class="text-left py-3 px-2 text-gray-400 font-medium cursor-pointer hover:text-white transition" onclick="sortThemeROI('theme')">Theme</th>
            <th class="text-right py-3 px-2 text-gray-400 font-medium cursor-pointer hover:text-white transition" onclick="sortThemeROI('sets')">Sets</th>
            <th class="text-right py-3 px-2 text-gray-400 font-medium cursor-pointer hover:text-white transition" onclick="sortThemeROI('invested')">Invested</th>
            <th class="text-right py-3 px-2 text-gray-400 font-medium cursor-pointer hover:text-white transition" onclick="sortThemeROI('value')">Current Value</th>
            <th class="text-right py-3 px-2 text-gray-400 font-medium cursor-pointer hover:text-white transition" onclick="sortThemeROI('gain')">Gain/Loss</th>
            <th class="text-right py-3 px-2 text-gray-400 font-medium cursor-pointer hover:text-white transition" onclick="sortThemeROI('roi')">ROI %</th>
            <th class="text-right py-3 px-2 text-gray-400 font-medium">vs Portfolio</th>
          </tr>
        </thead>
        <tbody id="themeROITableBody">
        </tbody>
      </table>
    </div>
  </div>

  <!-- Top Projected Gains -->
  <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-8">
    <div class="card rounded-xl p-4">
      <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">üöÄ Best 1yr Projected Growth</h3>
      <div id="topProjected" class="space-y-3"></div>
    </div>
    <div class="card rounded-xl p-4">
      <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">‚ö†Ô∏è Lowest 1yr Projected Growth</h3>
      <div id="bottomProjected" class="space-y-3"></div>
    </div>
  </div>

  <!-- Action Summary -->
  <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
    <div class="card rounded-xl p-4 glow-green cursor-pointer hover:scale-[1.02] transition" onclick="filterByAction('BUY')">
      <div class="flex items-center justify-between">
        <div>
          <div class="text-green-400 text-sm font-medium">üü¢ BUY</div>
          <div class="text-3xl font-bold text-green-400" id="buyCount">-</div>
        </div>
        <div class="text-5xl opacity-30">üìà</div>
      </div>
      <div class="text-sm text-gray-400 mt-2" id="buyThesis"></div>
    </div>
    <div class="card rounded-xl p-4 glow-yellow cursor-pointer hover:scale-[1.02] transition" onclick="filterByAction('HOLD')">
      <div class="flex items-center justify-between">
        <div>
          <div class="text-yellow-400 text-sm font-medium">‚è≥ HOLD</div>
          <div class="text-3xl font-bold text-yellow-400" id="holdCount">-</div>
        </div>
        <div class="text-5xl opacity-30">‚è∏Ô∏è</div>
      </div>
      <div class="text-sm text-gray-400 mt-2" id="holdThesis"></div>
    </div>
    <div class="card rounded-xl p-4 glow-red cursor-pointer hover:scale-[1.02] transition" onclick="filterByAction('SELL')">
      <div class="flex items-center justify-between">
        <div>
          <div class="text-red-400 text-sm font-medium">üî¥ SELL</div>
          <div class="text-3xl font-bold text-red-400" id="sellCount">-</div>
        </div>
        <div class="text-5xl opacity-30">üìâ</div>
      </div>
      <div class="text-sm text-gray-400 mt-2" id="sellThesis"></div>
    </div>
  </div>

  <!-- Top & Bottom Performers -->
  <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-8">
    <div class="card rounded-xl p-4">
      <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">üèÜ Top 5 Investment Scores</h3>
      <div id="topPerformers" class="space-y-3"></div>
    </div>
    <div class="card rounded-xl p-4">
      <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">‚ö†Ô∏è Underperformers</h3>
      <div id="bottomPerformers" class="space-y-3"></div>
    </div>
  </div>

  <!-- Tabs -->
  <div class="flex gap-6 border-b border-gray-700 mb-6">
    <button class="pb-2 tab-active" data-tab="all" onclick="switchTab('all')">All Sets</button>
    <button class="pb-2 text-gray-400 hover:text-white" data-tab="buy" onclick="switchTab('buy')">Buy</button>
    <button class="pb-2 text-gray-400 hover:text-white" data-tab="hold" onclick="switchTab('hold')">Hold</button>
    <button class="pb-2 text-gray-400 hover:text-white" data-tab="sell" onclick="switchTab('sell')">Sell</button>
  </div>

  <!-- Search & Filter -->
  <div class="flex flex-wrap gap-4 mb-6">
    <input type="text" id="searchInput" placeholder="üîç Search sets..." class="bg-gray-800 border border-gray-700 rounded-lg px-4 py-2 flex-1 min-w-[200px]" oninput="filterSets()">
    <select id="themeFilter" class="bg-gray-800 border border-gray-700 rounded-lg px-4 py-2" onchange="filterSets()">
      <option value="">All Themes</option>
    </select>
    <select id="sortBy" class="bg-gray-800 border border-gray-700 rounded-lg px-4 py-2" onchange="filterSets()">
      <option value="score">Sort by Score</option>
      <option value="growth">Sort by Growth</option>
      <option value="projected">Sort by Projected Growth</option>
      <option value="value">Sort by Value</option>
      <option value="name">Sort by Name</option>
    </select>
  </div>

  <!-- Sets Grid -->
  <div id="setsGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>

  <!-- Set Detail Modal -->
  <div id="modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm hidden items-center justify-center z-50 p-4">
    <div class="card rounded-2xl max-w-3xl w-full max-h-[90vh] overflow-y-auto">
      <div class="p-6" id="modalContent"></div>
    </div>
  </div>

  <script>
    // Data stores
    let portfolio = null;
    let analysis = null;
    let priceHistory = null;
    let currentTab = 'all';
    let currentFilter = '';
    let historyChart = null;
    let themeHistoryChart = null;

    // Transform new data format to expected format
    function transformPortfolio(data) {
      // If already in old format (sets is object), return as-is
      if (data.summary && !Array.isArray(data.sets)) return data;
      
      // Transform new format (sets is array, metadata instead of summary)
      const setsObj = {};
      (data.sets || []).forEach(set => {
        const id = set.setNumber || set.id;
        setsObj[id] = {
          name: set.name,
          theme: set.theme,
          retail_price: set.retail,
          price_paid: set.paid,
          current_value: set.value,
          qty_new: set.qtyNew,
          qty_used: set.qtyUsed,
          growth: set.growth
        };
      });
      
      const meta = data.metadata || {};
      return {
        sets: setsObj,
        summary: {
          total_current: meta.totalCurrentValue || 0,
          total_paid: meta.totalPaid || 0,
          total_gain_eur: (meta.totalCurrentValue || 0) - (meta.totalPaid || 0),
          total_gain_pct: meta.totalGain || 0,
          total_sets: meta.totalSets || Object.keys(setsObj).length,
          total_units: meta.totalUnits || 0,
          last_updated: meta.lastUpdated || new Date().toISOString()
        }
      };
    }

    // Load data
    async function loadData() {
      try {
        let rawPortfolio = await fetch('data/portfolio.json').then(r => r.json());
        portfolio = transformPortfolio(rawPortfolio);
        analysis = await fetch('data/deep-analysis.json').then(r => r.json());
        try {
          priceHistory = await fetch('data/price-history.json').then(r => r.json());
        } catch (e) {
          priceHistory = null;
        }
        renderDashboard();
      } catch (e) {
        console.error('Failed to load data:', e);
        document.getElementById('setsGrid').innerHTML = '<div class="text-red-400">Failed to load portfolio data</div>';
      }
    }

    function renderDashboard() {
      if (!portfolio || !analysis) return;

      // Calculate enriched data
      const sets = Object.entries(portfolio.sets).map(([id, data]) => {
        const a = analysis[id] || {};
        const avgScore = ((a.license || 0) + (a.retirement || 0) + (a.appeal || 0) + (a.liquidity || 0)) / 4;
        const predictions = a.predictions || {};
        return { id, ...data, analysis: a, avgScore, predictions };
      });

      // Summary
      document.getElementById('totalValue').textContent = '‚Ç¨' + portfolio.summary.total_current.toLocaleString('de-DE', {minimumFractionDigits: 2});
      document.getElementById('totalPaid').textContent = 'Paid: ‚Ç¨' + portfolio.summary.total_paid.toLocaleString('de-DE', {minimumFractionDigits: 2});
      
      const gain = portfolio.summary.total_gain_eur;
      const gainPct = portfolio.summary.total_gain_pct;
      const gainEl = document.getElementById('totalGain');
      const gainPctEl = document.getElementById('totalGainPct');
      gainEl.textContent = (gain >= 0 ? '+' : '') + '‚Ç¨' + gain.toLocaleString('de-DE', {minimumFractionDigits: 2});
      gainEl.className = 'text-2xl font-bold ' + (gain >= 0 ? 'text-green-400' : 'text-red-400');
      gainPctEl.textContent = (gainPct >= 0 ? '+' : '') + gainPct.toFixed(2) + '%';
      gainPctEl.className = 'text-sm ' + (gainPct >= 0 ? 'text-green-400' : 'text-red-400');

      const totalUnits = sets.reduce((sum, s) => sum + (s.qty_new || 0) + (s.qty_used || 0), 0);
      document.getElementById('totalSets').textContent = sets.length;
      document.getElementById('totalUnits').textContent = totalUnits + ' total units';

      const avgScore = sets.reduce((sum, s) => sum + s.avgScore, 0) / sets.length;
      document.getElementById('avgScore').textContent = avgScore.toFixed(1);

      // Calculate portfolio projections
      let projected1yr = 0;
      let projected5yr = 0;
      sets.forEach(s => {
        const qty = (s.qty_new || 0) + (s.qty_used || 0);
        const pred = s.predictions;
        if (pred && pred['1yr']) {
          projected1yr += (pred['1yr'].value || s.value) * qty;
        } else {
          projected1yr += s.value * qty * 1.15; // Default 15% growth estimate
        }
        if (pred && pred['5yr']) {
          projected5yr += (pred['5yr'].value || s.value) * qty;
        } else {
          projected5yr += s.value * qty * 1.8; // Default 80% growth estimate over 5yr
        }
      });

      const currentTotal = portfolio.summary.total_current;
      const growth1yr = ((projected1yr - currentTotal) / currentTotal) * 100;
      const growth5yr = ((projected5yr - currentTotal) / currentTotal) * 100;

      document.getElementById('forecast1yr').textContent = '‚Ç¨' + projected1yr.toLocaleString('de-DE', {minimumFractionDigits: 0});
      document.getElementById('forecast1yrGrowth').textContent = '+' + growth1yr.toFixed(1) + '% projected';

      document.getElementById('projection1yr').textContent = '‚Ç¨' + projected1yr.toLocaleString('de-DE', {minimumFractionDigits: 0});
      document.getElementById('projection1yrChange').innerHTML = `<span class="text-green-400">+‚Ç¨${(projected1yr - currentTotal).toLocaleString('de-DE', {minimumFractionDigits: 0})}</span> <span class="text-gray-400">(+${growth1yr.toFixed(1)}%)</span>`;

      document.getElementById('projection5yr').textContent = '‚Ç¨' + projected5yr.toLocaleString('de-DE', {minimumFractionDigits: 0});
      document.getElementById('projection5yrChange').innerHTML = `<span class="text-green-400">+‚Ç¨${(projected5yr - currentTotal).toLocaleString('de-DE', {minimumFractionDigits: 0})}</span> <span class="text-gray-400">(+${growth5yr.toFixed(1)}%)</span>`;

      // Top/Bottom projected
      const sortedByProjected = [...sets].sort((a, b) => {
        const aGrowth = a.predictions?.growth1yr || 15;
        const bGrowth = b.predictions?.growth1yr || 15;
        return bGrowth - aGrowth;
      });
      renderProjectedPerformers('topProjected', sortedByProjected.slice(0, 5), true);
      renderProjectedPerformers('bottomProjected', sortedByProjected.slice(-5).reverse(), false);

      // Action counts
      const buys = sets.filter(s => s.analysis.action === 'BUY');
      const holds = sets.filter(s => s.analysis.action === 'HOLD');
      const sells = sets.filter(s => s.analysis.action === 'SELL');

      document.getElementById('buyCount').textContent = buys.length;
      document.getElementById('holdCount').textContent = holds.length;
      document.getElementById('sellCount').textContent = sells.length;

      document.getElementById('buyThesis').textContent = buys.length > 0 ? buys[0].name : 'No buy recommendations';
      document.getElementById('sellThesis').textContent = sells.length > 0 ? `${sells.length} sets to consider selling` : 'No sell recommendations';
      document.getElementById('holdThesis').textContent = `${holds.length} sets performing as expected`;

      // Top/Bottom performers
      const sorted = [...sets].sort((a, b) => b.avgScore - a.avgScore);
      renderPerformers('topPerformers', sorted.slice(0, 5), true);
      renderPerformers('bottomPerformers', sorted.slice(-5).reverse(), false);

      // Theme filter
      const themes = [...new Set(sets.map(s => s.theme.split(' / ')[0]))].sort();
      const themeSelect = document.getElementById('themeFilter');
      themeSelect.innerHTML = '<option value="">All Themes</option>' + 
        themes.map(t => `<option value="${t}">${t}</option>`).join('');

      // Last updated
      document.getElementById('lastUpdated').textContent = 'Updated: ' + new Date(portfolio.summary.last_updated).toLocaleString();

      // Render history chart
      renderHistoryChart();

      // Render theme allocation chart
      renderThemeChart();

      // Render theme history chart
      renderThemeHistoryChart();

      // Render theme ROI table
      renderThemeROITable();

      // Render sets
      filterSets();
    }

    function renderHistoryChart() {
      if (!priceHistory) {
        document.getElementById('historyChart').parentElement.innerHTML = '<div class="text-gray-400 h-64 flex items-center justify-center">No price history data available</div>';
        return;
      }

      const range = document.getElementById('historyRange').value;
      const months = range === 'all' ? 999 : parseInt(range);
      
      // Aggregate portfolio value by month
      const monthlyData = {};
      
      // Get all unique dates across all sets
      const allDates = new Set();
      Object.values(priceHistory.sets).forEach(set => {
        if (set.priceHistory) {
          set.priceHistory.forEach(p => allDates.add(p.date.substring(0, 7)));
        }
      });
      
      const sortedDates = Array.from(allDates).sort();
      const recentDates = sortedDates.slice(-months);
      
      recentDates.forEach(month => {
        let totalValue = 0;
        Object.entries(portfolio.sets).forEach(([setId, setData]) => {
          const qty = (setData.qty_new || 0) + (setData.qty_used || 0);
          const historySet = priceHistory.sets[setId];
          if (historySet && historySet.priceHistory) {
            const monthData = historySet.priceHistory.find(p => p.date.startsWith(month));
            if (monthData) {
              totalValue += monthData.newValue * qty;
            } else {
              totalValue += setData.value; // fallback to current value
            }
          } else {
            totalValue += setData.value; // fallback
          }
        });
        monthlyData[month] = totalValue;
      });
      
      const labels = Object.keys(monthlyData);
      const values = Object.values(monthlyData);
      
      const ctx = document.getElementById('historyChart').getContext('2d');
      
      if (historyChart) historyChart.destroy();
      
      historyChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels.map(d => {
            const [y, m] = d.split('-');
            return new Date(y, m-1).toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
          }),
          datasets: [{
            label: 'Portfolio Value (‚Ç¨)',
            data: values,
            borderColor: '#8b5cf6',
            backgroundColor: 'rgba(139, 92, 246, 0.1)',
            fill: true,
            tension: 0.4,
            pointRadius: 2,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: (ctx) => '‚Ç¨' + ctx.raw.toLocaleString('de-DE', {minimumFractionDigits: 2})
              }
            }
          },
          scales: {
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: {
                color: '#9ca3af',
                callback: (v) => '‚Ç¨' + v.toLocaleString()
              }
            },
            x: {
              grid: { display: false },
              ticks: { color: '#9ca3af' }
            }
          }
        }
      });
    }

    function updateHistoryChart() {
      renderHistoryChart();
    }

    function renderThemeHistoryChart() {
      if (!priceHistory || !portfolio || !analysis) {
        const chartElement = document.getElementById('themeHistoryChart');
        if (chartElement) {
          chartElement.parentElement.innerHTML = '<div class="text-gray-400 h-64 flex items-center justify-center">No price history data available</div>';
        }
        return;
      }

      const range = document.getElementById('themeHistoryRange').value;
      const months = range === 'all' ? 999 : parseInt(range);

      // Get all sets with their theme info
      const sets = Object.entries(portfolio.sets).map(([id, data]) => {
        const a = analysis[id] || {};
        const avgScore = ((a.license || 0) + (a.retirement || 0) + (a.appeal || 0) + (a.liquidity || 0)) / 4;
        const predictions = a.predictions || {};
        return { id, ...data, analysis: a, avgScore, predictions };
      });

      // Aggregate by theme to get top 5 themes by current value
      const themeData = aggregateByTheme(sets);
      const topThemes = Object.entries(themeData)
        .sort((a, b) => b[1].totalValue - a[1].totalValue)
        .slice(0, 5)
        .map(([theme]) => theme);

      // Get all unique dates across all sets
      const allDates = new Set();
      Object.values(priceHistory.sets).forEach(set => {
        if (set.priceHistory) {
          set.priceHistory.forEach(p => allDates.add(p.date.substring(0, 7)));
        }
      });

      const sortedDates = Array.from(allDates).sort();
      const recentDates = sortedDates.slice(-months);

      // Color palette for themes (using same colors as theme chart)
      const colors = [
        '#8b5cf6', '#3b82f6', '#06b6d4', '#10b981', '#84cc16',
        '#eab308', '#f59e0b', '#ef4444', '#ec4899', '#a855f7'
      ];

      // Calculate historical value for each theme
      const datasets = topThemes.map((theme, index) => {
        const themeMonthlyData = {};
        const themeSets = themeData[theme].sets;

        recentDates.forEach(month => {
          let totalValue = 0;
          themeSets.forEach(set => {
            const qty = (set.qty_new || 0) + (set.qty_used || 0);
            const historySet = priceHistory.sets[set.id];
            if (historySet && historySet.priceHistory) {
              const monthData = historySet.priceHistory.find(p => p.date.startsWith(month));
              if (monthData) {
                totalValue += monthData.newValue * qty;
              } else {
                totalValue += set.value; // fallback to current value
              }
            } else {
              totalValue += set.value; // fallback
            }
          });
          themeMonthlyData[month] = totalValue;
        });

        return {
          label: theme,
          data: Object.values(themeMonthlyData),
          borderColor: colors[index % colors.length],
          backgroundColor: colors[index % colors.length] + '20',
          fill: false,
          tension: 0.4,
          pointRadius: 2,
          pointHoverRadius: 6
        };
      });

      const labels = recentDates.map(d => {
        const [y, m] = d.split('-');
        return new Date(y, m-1).toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
      });

      const ctx = document.getElementById('themeHistoryChart');
      if (!ctx) return;

      if (themeHistoryChart) themeHistoryChart.destroy();

      themeHistoryChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'bottom',
              labels: {
                color: '#9ca3af',
                padding: 10,
                font: {
                  size: 11
                },
                usePointStyle: true,
                pointStyle: 'line'
              }
            },
            tooltip: {
              callbacks: {
                label: (ctx) => `${ctx.dataset.label}: ‚Ç¨${ctx.raw.toLocaleString('de-DE', {minimumFractionDigits: 2})}`
              }
            }
          },
          scales: {
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: {
                color: '#9ca3af',
                callback: (v) => '‚Ç¨' + v.toLocaleString()
              }
            },
            x: {
              grid: { display: false },
              ticks: { color: '#9ca3af' }
            }
          }
        }
      });
    }

    function updateThemeHistoryChart() {
      renderThemeHistoryChart();
    }

    let themeChart = null;
    function renderThemeChart() {
      if (!portfolio || !analysis) return;

      const sets = Object.entries(portfolio.sets).map(([id, data]) => {
        const a = analysis[id] || {};
        const avgScore = ((a.license || 0) + (a.retirement || 0) + (a.appeal || 0) + (a.liquidity || 0)) / 4;
        const predictions = a.predictions || {};
        return { id, ...data, analysis: a, avgScore, predictions };
      });

      // Aggregate portfolio by theme
      const themeData = aggregateByTheme(sets);
      const themeValues = Object.entries(themeData)
        .map(([theme, data]) => ({
          theme: theme,
          value: data.totalValue
        }))
        .sort((a, b) => b.value - a.value);

      // Prepare chart data
      const labels = themeValues.map(t => t.theme);
      const values = themeValues.map(t => t.value);
      const total = values.reduce((sum, v) => sum + v, 0);
      const percentages = values.map(v => ((v / total) * 100).toFixed(1));

      // Color palette for themes
      const colors = [
        '#8b5cf6', '#3b82f6', '#06b6d4', '#10b981', '#84cc16',
        '#eab308', '#f59e0b', '#ef4444', '#ec4899', '#a855f7',
        '#6366f1', '#14b8a6', '#22c55e', '#facc15', '#fb923c'
      ];

      const ctx = document.getElementById('themeChart');
      if (!ctx) return;

      if (themeChart) {
        themeChart.destroy();
      }

      themeChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: labels,
          datasets: [{
            data: values,
            backgroundColor: colors.slice(0, labels.length),
            borderColor: '#1a1a2e',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'right',
              labels: {
                color: '#9ca3af',
                padding: 12,
                font: {
                  size: 11
                },
                generateLabels: (chart) => {
                  const data = chart.data;
                  return data.labels.map((label, i) => ({
                    text: `${label} (${percentages[i]}%)`,
                    fillStyle: data.datasets[0].backgroundColor[i],
                    hidden: false,
                    index: i
                  }));
                }
              }
            },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const value = ctx.raw;
                  const percentage = ((value / total) * 100).toFixed(1);
                  return `‚Ç¨${value.toLocaleString('de-DE', {minimumFractionDigits: 2})} (${percentage}%)`;
                }
              }
            }
          }
        }
      });
    }

    // Theme aggregation functions
    function aggregateByTheme(sets) {
      const themeData = {};

      sets.forEach(set => {
        const theme = set.theme || 'Unknown';
        if (!themeData[theme]) {
          themeData[theme] = {
            theme: theme,
            totalValue: 0,
            totalPaid: 0,
            totalGain: 0,
            totalUnits: 0,
            setCount: 0,
            sets: []
          };
        }

        const qty = (set.qty_new || 0) + (set.qty_used || 0);
        const value = set.current_value || 0;
        const paid = set.price_paid || 0;

        themeData[theme].totalValue += value;
        themeData[theme].totalPaid += paid;
        themeData[theme].totalGain += (value - paid);
        themeData[theme].totalUnits += qty;
        themeData[theme].setCount += 1;
        themeData[theme].sets.push(set);
      });

      // Calculate percentages and ROI for each theme
      Object.values(themeData).forEach(theme => {
        theme.gainPct = theme.totalPaid > 0 ? ((theme.totalGain / theme.totalPaid) * 100) : 0;
        theme.avgScore = theme.sets.reduce((sum, s) => sum + (s.avgScore || 0), 0) / theme.sets.length;
      });

      return themeData;
    }

    // Theme ROI table rendering
    let currentThemeROISort = 'roi';
    let themeROISortDirection = 'desc';

    function renderThemeROITable() {
      if (!portfolio || !analysis) return;

      const sets = Object.entries(portfolio.sets).map(([id, data]) => {
        const a = analysis[id] || {};
        const avgScore = ((a.license || 0) + (a.retirement || 0) + (a.appeal || 0) + (a.liquidity || 0)) / 4;
        const predictions = a.predictions || {};
        return { id, ...data, analysis: a, avgScore, predictions };
      });

      const themeData = aggregateByTheme(sets);
      const sortBy = document.getElementById('themeROISort')?.value || currentThemeROISort;

      let themeArray = Object.values(themeData);

      // Sort based on selected criterion
      themeArray.sort((a, b) => {
        let aVal, bVal;
        switch(sortBy) {
          case 'theme':
            return themeROISortDirection === 'asc'
              ? a.theme.localeCompare(b.theme)
              : b.theme.localeCompare(a.theme);
          case 'sets':
            aVal = a.setCount;
            bVal = b.setCount;
            break;
          case 'invested':
            aVal = a.totalPaid;
            bVal = b.totalPaid;
            break;
          case 'value':
            aVal = a.totalValue;
            bVal = b.totalValue;
            break;
          case 'gain':
            aVal = a.totalGain;
            bVal = b.totalGain;
            break;
          case 'roi':
          default:
            aVal = a.gainPct;
            bVal = b.gainPct;
            break;
        }
        return themeROISortDirection === 'desc' ? bVal - aVal : aVal - bVal;
      });

      const tbody = document.getElementById('themeROITableBody');
      if (!tbody) return;

      // Calculate portfolio average ROI (weighted by invested amount)
      const totalInvested = themeArray.reduce((sum, t) => sum + t.totalPaid, 0);
      const totalValue = themeArray.reduce((sum, t) => sum + t.totalValue, 0);
      const portfolioAvgROI = totalInvested > 0 ? ((totalValue - totalInvested) / totalInvested) * 100 : 0;

      tbody.innerHTML = themeArray.map(theme => {
        const roiColor = theme.gainPct >= 20 ? 'text-green-400' :
                         theme.gainPct >= 0 ? 'text-yellow-400' : 'text-red-400';
        const roiBg = theme.gainPct >= 20 ? 'bg-green-500/10' :
                      theme.gainPct >= 0 ? 'bg-yellow-500/10' : 'bg-red-500/10';
        const gainColor = theme.totalGain >= 0 ? 'text-green-400' : 'text-red-400';
        const gainIcon = theme.totalGain >= 0 ? '‚Üë' : '‚Üì';

        // Calculate performance vs portfolio average (in percentage points)
        const vsBenchmark = theme.gainPct - portfolioAvgROI;
        const benchmarkColor = vsBenchmark > 0 ? 'text-green-400' : 'text-red-400';
        const benchmarkBg = vsBenchmark > 0 ? 'bg-green-500/10' : 'bg-red-500/10';
        const benchmarkIcon = vsBenchmark > 0 ? '‚Üë' : '‚Üì';

        return `
          <tr class="border-b border-gray-800 hover:bg-gray-800/50 transition">
            <td class="py-3 px-2 font-medium">${theme.theme}</td>
            <td class="py-3 px-2 text-right text-gray-400">${theme.setCount}</td>
            <td class="py-3 px-2 text-right">‚Ç¨${theme.totalPaid.toFixed(0)}</td>
            <td class="py-3 px-2 text-right font-medium">‚Ç¨${theme.totalValue.toFixed(0)}</td>
            <td class="py-3 px-2 text-right ${gainColor} font-medium">${gainIcon} ‚Ç¨${Math.abs(theme.totalGain).toFixed(0)}</td>
            <td class="py-3 px-2 text-right">
              <span class="${roiBg} ${roiColor} px-2 py-1 rounded font-bold">
                ${theme.gainPct >= 0 ? '+' : ''}${theme.gainPct.toFixed(1)}%
              </span>
            </td>
            <td class="py-3 px-2 text-right">
              <span class="${benchmarkBg} ${benchmarkColor} px-2 py-1 rounded font-medium">
                ${benchmarkIcon} ${vsBenchmark > 0 ? '+' : ''}${vsBenchmark.toFixed(1)} pp
              </span>
            </td>
          </tr>
        `;
      }).join('');
    }

    function sortThemeROI(column) {
      if (currentThemeROISort === column) {
        themeROISortDirection = themeROISortDirection === 'desc' ? 'asc' : 'desc';
      } else {
        currentThemeROISort = column;
        themeROISortDirection = column === 'theme' ? 'asc' : 'desc';
      }

      // Update dropdown to match
      const dropdown = document.getElementById('themeROISort');
      if (dropdown && ['roi', 'value', 'gain', 'theme'].includes(column)) {
        dropdown.value = column;
      }

      renderThemeROITable();
    }

    function calculateThemeAllocation(themeData, totalValue) {
      const allocation = {};

      Object.entries(themeData).forEach(([theme, data]) => {
        allocation[theme] = {
          ...data,
          allocationPct: totalValue > 0 ? (data.totalValue / totalValue) * 100 : 0
        };
      });

      return allocation;
    }

    function getTopThemesByMetric(themeData, metric, limit = 5) {
      return Object.values(themeData)
        .sort((a, b) => b[metric] - a[metric])
        .slice(0, limit);
    }

    function getThemeHistoricalPerformance(theme) {
      if (!priceHistory) return null;

      const monthlyData = {};

      // Get all unique dates
      const allDates = new Set();
      Object.values(priceHistory.sets).forEach(set => {
        if (set.priceHistory) {
          set.priceHistory.forEach(p => allDates.add(p.date.substring(0, 7)));
        }
      });

      const sortedDates = Array.from(allDates).sort();

      sortedDates.forEach(month => {
        let totalValue = 0;
        Object.entries(portfolio.sets).forEach(([setId, setData]) => {
          if (setData.theme === theme) {
            const qty = (setData.qty_new || 0) + (setData.qty_used || 0);
            const historySet = priceHistory.sets[setId];
            if (historySet && historySet.priceHistory) {
              const monthData = historySet.priceHistory.find(p => p.date.startsWith(month));
              if (monthData) {
                totalValue += monthData.newValue * qty;
              } else {
                totalValue += setData.current_value || 0;
              }
            } else {
              totalValue += setData.current_value || 0;
            }
          }
        });
        monthlyData[month] = totalValue;
      });

      return monthlyData;
    }

    function renderProjectedPerformers(containerId, sets, isTop) {
      const container = document.getElementById(containerId);
      container.innerHTML = sets.map((s, i) => {
        const growth = s.predictions?.growth1yr || 15;
        const color = growth > 20 ? 'text-green-400' : growth > 10 ? 'text-yellow-400' : 'text-red-400';
        const value1yr = s.predictions?.['1yr']?.value || (s.value * 1.15);
        return `
          <div class="flex items-center justify-between p-2 bg-gray-800/50 rounded-lg cursor-pointer hover:bg-gray-700/50 transition" onclick="showDetail('${s.id}')">
            <div class="flex items-center gap-3">
              <span class="text-gray-500 text-sm w-5">${i + 1}</span>
              <div>
                <div class="font-medium text-sm">${s.name}</div>
                <div class="text-xs text-gray-400">Current: ‚Ç¨${s.value.toFixed(0)}</div>
              </div>
            </div>
            <div class="text-right">
              <div class="font-bold ${color}">+${growth.toFixed(1)}%</div>
              <div class="text-xs text-purple-400">‚Üí ‚Ç¨${value1yr.toFixed(0)}</div>
            </div>
          </div>
        `;
      }).join('');
    }

    function renderPerformers(containerId, sets, isTop) {
      const container = document.getElementById(containerId);
      container.innerHTML = sets.map((s, i) => {
        const color = isTop ? 'text-green-400' : 'text-red-400';
        const icon = isTop ? '‚Üë' : '‚Üì';
        return `
          <div class="flex items-center justify-between p-2 bg-gray-800/50 rounded-lg cursor-pointer hover:bg-gray-700/50 transition" onclick="showDetail('${s.id}')">
            <div class="flex items-center gap-3">
              <span class="text-gray-500 text-sm w-5">${isTop ? i + 1 : ''}</span>
              <div>
                <div class="font-medium text-sm">${s.name}</div>
                <div class="text-xs text-gray-400">${s.analysis.thesis?.slice(0, 50)}...</div>
              </div>
            </div>
            <div class="text-right">
              <div class="font-bold ${color}">${s.avgScore.toFixed(1)}/10</div>
              <div class="text-xs ${s.growth_pct >= 0 ? 'text-green-400' : 'text-red-400'}">${icon} ${s.growth_pct.toFixed(1)}%</div>
            </div>
          </div>
        `;
      }).join('');
    }

    function switchTab(tab) {
      currentTab = tab;
      document.querySelectorAll('[data-tab]').forEach(btn => {
        btn.classList.remove('tab-active', 'text-blue-400');
        btn.classList.add('text-gray-400');
      });
      document.querySelector(`[data-tab="${tab}"]`).classList.add('tab-active');
      document.querySelector(`[data-tab="${tab}"]`).classList.remove('text-gray-400');
      filterSets();
    }

    function filterByAction(action) {
      currentTab = action.toLowerCase();
      switchTab(currentTab);
    }

    function filterSets() {
      const search = document.getElementById('searchInput').value.toLowerCase();
      const theme = document.getElementById('themeFilter').value;
      const sortBy = document.getElementById('sortBy').value;

      let sets = Object.entries(portfolio.sets).map(([id, data]) => {
        const a = analysis[id] || {};
        const avgScore = ((a.license || 0) + (a.retirement || 0) + (a.appeal || 0) + (a.liquidity || 0)) / 4;
        const predictions = a.predictions || {};
        return { id, ...data, analysis: a, avgScore, predictions };
      });

      // Filter by tab
      if (currentTab !== 'all') {
        sets = sets.filter(s => s.analysis.action?.toLowerCase() === currentTab);
      }

      // Filter by search
      if (search) {
        sets = sets.filter(s => s.name.toLowerCase().includes(search) || s.theme.toLowerCase().includes(search));
      }

      // Filter by theme
      if (theme) {
        sets = sets.filter(s => s.theme.startsWith(theme));
      }

      // Sort
      if (sortBy === 'score') sets.sort((a, b) => b.avgScore - a.avgScore);
      else if (sortBy === 'growth') sets.sort((a, b) => b.growth_pct - a.growth_pct);
      else if (sortBy === 'projected') sets.sort((a, b) => (b.predictions?.growth1yr || 15) - (a.predictions?.growth1yr || 15));
      else if (sortBy === 'value') sets.sort((a, b) => b.value - a.value);
      else if (sortBy === 'name') sets.sort((a, b) => a.name.localeCompare(b.name));

      renderSets(sets);
    }

    function renderSets(sets) {
      const grid = document.getElementById('setsGrid');
      grid.innerHTML = sets.map(s => {
        const action = s.analysis.action || 'UNKNOWN';
        const actionColors = { BUY: 'bg-green-500/20 text-green-400 border-green-500/30', HOLD: 'bg-yellow-500/20 text-yellow-400 border-yellow-500/30', SELL: 'bg-red-500/20 text-red-400 border-red-500/30' };
        const actionIcons = { BUY: 'üü¢', HOLD: '‚è≥', SELL: 'üî¥' };
        const growthColor = s.growth_pct >= 0 ? 'text-green-400' : 'text-red-400';
        const entryColors = { excellent: 'text-green-400', good: 'text-blue-400', fair: 'text-yellow-400', poor: 'text-red-400' };
        const projected1yr = s.predictions?.['1yr']?.value || (s.value * 1.15);
        const projectedGrowth = s.predictions?.growth1yr || 15;

        return `
          <div class="card rounded-xl p-4 cursor-pointer hover:bg-white/10 transition" onclick="showDetail('${s.id}')">
            <div class="flex justify-between items-start mb-3">
              <div class="flex-1">
                <h3 class="font-semibold text-white">${s.name}</h3>
                <p class="text-xs text-gray-400">${s.theme}</p>
              </div>
              <span class="px-2 py-1 rounded-full text-xs font-medium border ${actionColors[action] || 'bg-gray-500/20'}">
                ${actionIcons[action] || '‚ùì'} ${action}
              </span>
            </div>
            
            <div class="grid grid-cols-3 gap-2 mb-3">
              <div>
                <div class="text-xs text-gray-400">Value</div>
                <div class="font-bold text-sm">‚Ç¨${s.value.toLocaleString('de-DE', {minimumFractionDigits: 0})}</div>
              </div>
              <div>
                <div class="text-xs text-gray-400">Growth</div>
                <div class="font-bold text-sm ${growthColor}">${s.growth_pct >= 0 ? '+' : ''}${s.growth_pct.toFixed(1)}%</div>
              </div>
              <div>
                <div class="text-xs text-purple-400 flex items-center gap-1">üîÆ 1yr</div>
                <div class="font-bold text-sm text-purple-400">+${projectedGrowth.toFixed(0)}%</div>
              </div>
            </div>

            <div class="flex items-center justify-between text-sm">
              <div class="flex items-center gap-2">
                <span class="text-gray-400">Score:</span>
                <span class="font-bold text-blue-400">${s.avgScore.toFixed(1)}/10</span>
              </div>
              <div class="flex items-center gap-2">
                <span class="text-gray-400">Entry:</span>
                <span class="${entryColors[s.analysis.entry] || 'text-gray-400'}">${s.analysis.entry || '-'}</span>
              </div>
            </div>

            <div class="mt-3 pt-3 border-t border-gray-700">
              <p class="text-xs text-gray-400 line-clamp-2">${s.analysis.thesis || 'No analysis available'}</p>
            </div>
          </div>
        `;
      }).join('');
    }

    function showDetail(id) {
      const s = { id, ...portfolio.sets[id], analysis: analysis[id] || {} };
      const avgScore = ((s.analysis.license || 0) + (s.analysis.retirement || 0) + (s.analysis.appeal || 0) + (s.analysis.liquidity || 0)) / 4;
      const predictions = s.analysis.predictions || {};

      const actionColors = { BUY: 'bg-green-500 text-white', HOLD: 'bg-yellow-500 text-black', SELL: 'bg-red-500 text-white' };
      const entryColors = { excellent: 'bg-green-500/20 text-green-400', good: 'bg-blue-500/20 text-blue-400', fair: 'bg-yellow-500/20 text-yellow-400', poor: 'bg-red-500/20 text-red-400' };
      const growthColor = s.growth_pct >= 0 ? 'text-green-400' : 'text-red-400';

      const pred1yr = predictions['1yr']?.value || (s.value * 1.15);
      const pred5yr = predictions['5yr']?.value || (s.value * 1.8);
      const growth1yr = predictions.growth1yr || 15;
      const growth5yr = predictions.growth5yr || 80;

      const content = `
        <div class="flex justify-between items-start mb-6">
          <div>
            <h2 class="text-2xl font-bold">${s.name}</h2>
            <p class="text-gray-400">${s.theme} ‚Ä¢ ${s.id}</p>
          </div>
          <button onclick="closeModal()" class="text-gray-400 hover:text-white text-2xl">&times;</button>
        </div>

        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
          <div class="bg-gray-800 rounded-lg p-3">
            <div class="text-xs text-gray-400">Current Value</div>
            <div class="text-xl font-bold">‚Ç¨${s.value.toLocaleString('de-DE', {minimumFractionDigits: 2})}</div>
          </div>
          <div class="bg-gray-800 rounded-lg p-3">
            <div class="text-xs text-gray-400">Paid</div>
            <div class="text-xl font-bold">‚Ç¨${s.paid.toLocaleString('de-DE', {minimumFractionDigits: 2})}</div>
          </div>
          <div class="bg-gray-800 rounded-lg p-3">
            <div class="text-xs text-gray-400">Growth</div>
            <div class="text-xl font-bold ${growthColor}">${s.growth_pct >= 0 ? '+' : ''}${s.growth_pct.toFixed(2)}%</div>
          </div>
          <div class="bg-gray-800 rounded-lg p-3">
            <div class="text-xs text-gray-400">Quantity</div>
            <div class="text-xl font-bold">${s.qty_new} new / ${s.qty_used} used</div>
          </div>
        </div>

        <!-- Predictions Section -->
        <div class="bg-gradient-to-br from-purple-900/30 to-indigo-900/30 rounded-xl p-4 mb-6 border border-purple-500/20">
          <div class="flex items-center gap-2 mb-4">
            <span class="text-xl">üîÆ</span>
            <h3 class="font-semibold">BrickEconomy ML Predictions</h3>
            <span class="prediction-badge px-2 py-0.5 rounded-full text-xs">Data-driven estimates</span>
          </div>
          <div class="grid grid-cols-2 gap-4">
            <div class="bg-black/20 rounded-lg p-3">
              <div class="text-xs text-purple-300">1-Year Estimate (Jan 2026)</div>
              <div class="text-2xl font-bold text-white">‚Ç¨${pred1yr.toFixed(0)}</div>
              <div class="text-sm text-green-400">+${growth1yr.toFixed(1)}% projected</div>
            </div>
            <div class="bg-black/20 rounded-lg p-3">
              <div class="text-xs text-indigo-300">5-Year Estimate (Jan 2030)</div>
              <div class="text-2xl font-bold text-white">‚Ç¨${pred5yr.toFixed(0)}</div>
              <div class="text-sm text-green-400">+${growth5yr.toFixed(1)}% projected</div>
            </div>
          </div>
          <p class="text-xs text-gray-400 mt-3">
            Predictions based on BrickEconomy's machine learning model trained on historical LEGO market data.
            Not financial advice.
          </p>
        </div>

        <div class="flex gap-3 mb-6">
          <span class="px-4 py-2 rounded-lg font-bold ${actionColors[s.analysis.action] || 'bg-gray-500'}">${s.analysis.action || 'N/A'}</span>
          <span class="px-4 py-2 rounded-lg ${entryColors[s.analysis.entry] || 'bg-gray-500/20'}">Entry: ${s.analysis.entry || '-'}</span>
          <span class="px-4 py-2 rounded-lg bg-blue-500/20 text-blue-400">Confidence: ${s.analysis.confidence || '-'}</span>
        </div>

        <div class="bg-gray-800 rounded-lg p-4 mb-6">
          <h3 class="font-semibold mb-2">üß† AI Analysis</h3>
          <p class="text-gray-300">${s.analysis.thesis || 'No analysis available'}</p>
        </div>

        <div class="mb-6">
          <h3 class="font-semibold mb-3">üìä Score Breakdown</h3>
          <div class="space-y-3">
            ${renderScoreBar('License Strength', s.analysis.license)}
            ${renderScoreBar('Retirement Risk', s.analysis.retirement)}
            ${renderScoreBar('Collector Appeal', s.analysis.appeal)}
            ${renderScoreBar('Market Liquidity', s.analysis.liquidity)}
          </div>
          <div class="mt-4 p-3 bg-blue-500/20 rounded-lg flex justify-between items-center">
            <span class="font-semibold">Overall Investment Score</span>
            <span class="text-2xl font-bold text-blue-400">${avgScore.toFixed(1)}/10</span>
          </div>
        </div>

        ${s.purchaseDate ? `<div class="bg-gray-800 rounded-lg p-4 mb-4"><span class="text-gray-400">üìÖ Purchase Date:</span> <span class="text-white">${s.purchaseDate}</span></div>` : ''}
        ${s.notes ? `<div class="bg-gray-800 rounded-lg p-4"><h3 class="font-semibold mb-2">üìù Notes</h3><p class="text-gray-300">${s.notes}</p></div>` : ''}
      `;

      document.getElementById('modalContent').innerHTML = content;
      document.getElementById('modal').classList.remove('hidden');
      document.getElementById('modal').classList.add('flex');
    }

    function renderScoreBar(label, value) {
      const pct = ((value || 0) / 10) * 100;
      const color = value >= 7 ? 'bg-green-500' : value >= 4 ? 'bg-yellow-500' : 'bg-red-500';
      return `
        <div class="flex items-center gap-3">
          <span class="text-sm text-gray-400 w-32">${label}</span>
          <div class="flex-1 bg-gray-700 rounded-full h-2 overflow-hidden">
            <div class="${color} h-full rounded-full" style="width: ${pct}%"></div>
          </div>
          <span class="text-sm font-bold w-8">${value || 0}</span>
        </div>
      `;
    }

    function closeModal() {
      document.getElementById('modal').classList.add('hidden');
      document.getElementById('modal').classList.remove('flex');
    }

    function refreshData() {
      loadData();
    }

    // Close modal on background click
    document.getElementById('modal').addEventListener('click', (e) => {
      if (e.target.id === 'modal') closeModal();
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeModal();
    });

    // Initialize
    loadData();
  </script>
</body>
</html>
